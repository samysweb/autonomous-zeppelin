SharedDefinitions
  Real p;
  Real r;
  Real T;
  Real norm(Real x, Real y) = (x^2+y^2)^(1/2);
  Real sp(Real x1, Real x2, Real y1, Real y2) = x1*y1 + x2*y2;
  Bool slipstream(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w,
        Real v1,
        Real v2) <-> (
            sp(x1,x2,-v1,-v2)<=-c2
        );
  Bool farAway(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w,
        Real v1,
        Real v2) <-> (
            sp(x1,x2,-v1,-v2)>(c2+(w/(p-r))*c1)
        );
  Bool onSideGeneric(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w,
        Real v1,
        Real v2,
        Real f) <-> (
            f*sp(x1,x2,v2,-v1)-((p-r)/w * (c2-sp(x1,x2,-v1,-v2)) + c1) >= 0
        );
  Bool onSide1(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w,
        Real v1,
        Real v2) <-> onSideGeneric(x1, x2, c1, c2, w, v1, v2, 1.0);
  Bool onSide2(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w,
        Real v1,
        Real v2) <-> onSideGeneric(x1, x2, c1, c2, w, v1, v2, -1.0);
  Bool outsideDanger(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w,
        Real v1,
        Real v2) <-> w>0&c1>0&c2>0&(
            slipstream(x1, x2, c1, c2, w, v1, v2) |
            farAway(x1, x2, c1, c2, w, v1, v2) |
            onSide1(x1, x2, c1, c2, w, v1, v2) |
            onSide2(x1, x2, c1, c2, w, v1, v2)
        );
  Bool outsideDangerWindSystem(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real w) <-> (
            outsideDanger(x1,x2,c1,c2,w,0.0,-1.0)
        );
  Bool outsideObstacle(
        Real x1,
        Real x2,
        Real c1,
        Real c2) <-> (
            x1 <= -c1 | c1 <= x1 |
            x2 <= -c2 | c2 <= x2
        );
  Bool outsideDangerAnySystem(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real o1,
        Real o2,
        Real v1,
        Real v2) <-> outsideDanger(
                x1-o1,
                x2-o2,
                c1,
                c2,
                norm(v1,v2),
                v1/norm(v1,v2),
                v2/norm(v1,v2)
            );
  Bool obstacleParamCondition(
        Real x1,
        Real x2,
        Real c1,
        Real c2,
        Real o1,
        Real o2,
        Real v1,
        Real v2) <-> (
            p-r < norm(v1,v2) & c1>0 & c2>0 &
            outsideDangerAnySystem(x1,x2,c1,c2,o1,o2,v1,v2)
        );
  Real afterwards1(Real x, Real y, Real w) = x+T*p*y;
  Real afterwards2(Real x, Real y, Real w) = x+T*p*y-T*w;
  Bool controllerCondition(
        Real x1,
        Real x2,
        Real y1,
        Real y2,
        Real c1,
        Real c2,
        Real w) <-> (
            y1^2+y2^2<=1 & (
                (
                    slipstream(x1, x2, c1, c2, w, 0.0, -1.0) ->
                    slipstream(afterwards1(x1,y1,w),afterwards2(x2,y2,w)+T*r,c1,c2,w,0.0,-1.0)
                ) & (
                    farAway(x1, x2, c1, c2, w, 0.0, -1.0) ->
                    farAway(afterwards1(x1,y1,w),afterwards2(x2,y2,w)-T*r,c1,c2,w,0.0,-1.0)
                ) & (
                    onSide1(x1, x2, c1, c2, w, 0.0, -1.0) ->
                    onSide1(afterwards1(x1,y1,w)+T*r,afterwards2(x2,y2,w)-T*r,c1,c2,w,0.0,-1.0)
                ) & (
                    onSide2(x1, x2, c1, c2, w, 0.0, -1.0) ->
                    onSide2(afterwards1(x1,y1,w)-T*r,afterwards2(x2,y2,w)-T*r,c1,c2,w,0.0,-1.0)
                )
            )
        );
  HP ctrl ::= {
        y1 := *;
        y2 := *;
        ?(controllerCondition(x1,x2,y1,y2,c1,c2,w));
    };
  HP setTurbulence ::= {
        z1 := *; z2 := *;
        ?(z1^2+z2^2<=1);
    };
  HP model ::= {
        {
            setTurbulence;
            t:=0;
        };
        {x1'=p*y1+r*z1, x2'=-w+p*y2+r*z2, t'=1 & t <= T }
    };
End.
Lemma "ZeppelinV3/controllerPreservation"
ProgramVariables
    /* IN */
    /* Zeppelin Position */
    Real x1;
    Real x2;
    /* Obstacle size */
    Real c1;
    Real c2;
    /* Wind velocity */
    Real w;
    
    /* OUT */
    /* Zeppelin Velocity */
    Real y1;
    Real y2;
    
    /* Intermediate */
    /* Turbulence direction & strength */
    Real z1;
    Real z2;
    
    /* Clock */
    Real t;
End.
Problem
(p > r & r > 0 & T > 0 & outsideDangerWindSystem(x1,x2,c1,c2,w))
->
[ctrl;][model;]outsideDangerWindSystem(x1,x2,c1,c2,w)
End.
Tactic "Safety Preservation Proof"
implyR('R=="p()>r()&r()>0&T()>0&outsideDangerWindSystem(x1,x2,c1,c2,w)->[ctrl{|^@|};][model{|^@|};]outsideDangerWindSystem(x1,x2,c1,c2,w)");
expand "ctrl";
expand "model";
composeb('R=="[y1:=*;y2:=*;?controllerCondition(x1,x2,y1,y2,c1,c2,w);]#[{setTurbulence{|^@|};t:=0;}{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}]outsideDangerWindSystem(x1,x2,c1,c2,w)#");
composeb('R=="[y1:=*;y2:=*;?controllerCondition(x1,x2,y1,y2,c1,c2,w);]#[setTurbulence{|^@|};t:=0;][{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}]outsideDangerWindSystem(x1,x2,c1,c2,w)#");
expand "setTurbulence";
unfold;
expand "outsideDangerWindSystem";
expand "outsideDanger";
unfold;
orL('L=="slipstream(x1,x2,c1,c2,w,0.0,(-1.0))|farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))"); <(
  "slipstream(x1,x2,c1,c2,w,0.0,(-1.0))":
    expand "controllerCondition";
    unfold;
    hideL('L=="onSide2(x1,x2,c1,c2,w,0.0,(-1.0))->onSide2(afterwards1(x1,y1,w)-T()*r(),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
    hideL('L=="onSide1(x1,x2,c1,c2,w,0.0,(-1.0))->onSide1(afterwards1(x1,y1,w)+T()*r(),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
    hideL('L=="farAway(x1,x2,c1,c2,w,0.0,(-1.0))->farAway(afterwards1(x1,y1,w),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
    MR("w>0&c1>0&c2>0&slipstream(x1,x2,c1,c2,w,0.0,(-1.0))", 'R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&(slipstream(x1,x2,c1,c2,w,0.0,(-1.0))|farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))))"); <(
      "Use Q->P":
        cut("!!-w+p()*y2+r()*z2<=0"); <(
          "Use":
            dIRule('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&slipstream(x1,x2,c1,c2,w,0.0,(-1.0)))"); <(
              "dI Init":
                auto,
              "dI Step":
                auto
            ),
          "Show":
            notR('R=="!!-w+p()*y2+r()*z2<=0");
            notLessEqual('L=="!-w+p()*y2+r()*z2<=0");
            solve('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&slipstream(x1,x2,c1,c2,w,0.0,(-1.0)))");
            unfold;
            expand "slipstream";
            expand "sp";
            fullSimplify;
            expand "afterwards2";
            fullSimplify;
            QE
        ),
      "Show [a]Q":
        auto
    ),
  "farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))":
    orL('L=="farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))"); <(
      "farAway(x1,x2,c1,c2,w,0.0,(-1.0))":
        MR("w>0&c1>0&c2>0&farAway(x1,x2,c1,c2,w,0.0,(-1.0))", 'R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&(slipstream(x1,x2,c1,c2,w,0.0,(-1.0))|farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))))"); <(
          "Use Q->P":
            expand "controllerCondition";
            unfold;
            hideL('L=="onSide2(x1,x2,c1,c2,w,0.0,(-1.0))->onSide2(afterwards1(x1,y1,w)-T()*r(),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
            hideL('L=="onSide1(x1,x2,c1,c2,w,0.0,(-1.0))->onSide1(afterwards1(x1,y1,w)+T()*r(),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
            hideL('L=="slipstream(x1,x2,c1,c2,w,0.0,(-1.0))->slipstream(afterwards1(x1,y1,w),afterwards2(x2,y2,w)+T()*r(),c1,c2,w,0.0,(-1.0))");
            cut("!!-w+p()*y2+r()*z2>=0"); <(
              "Use":
                dIRule('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&farAway(x1,x2,c1,c2,w,0.0,(-1.0)))"); <(
                  "dI Init":
                    auto,
                  "dI Step":
                    auto
                ),
              "Show":
                notR('R=="!!-w+p()*y2+r()*z2>=0");
                notGreaterEqual('L=="!-w+p()*y2+r()*z2>=0");
                solve('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&farAway(x1,x2,c1,c2,w,0.0,(-1.0)))");
                unfold;
                expand "farAway";
                expand "sp";
                fullSimplify;
                expand "afterwards2";
                QE
            ),
          "Show [a]Q":
            auto
        ),
      "onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))":
        orL('L=="onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))"); <(
          "onSide1(x1,x2,c1,c2,w,0.0,(-1.0))":
            expand "controllerCondition";
            unfold;
            hideL('L=="onSide2(x1,x2,c1,c2,w,0.0,(-1.0))->onSide2(afterwards1(x1,y1,w)-T()*r(),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
            hideL('L=="farAway(x1,x2,c1,c2,w,0.0,(-1.0))->farAway(afterwards1(x1,y1,w),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
            hideL('L=="slipstream(x1,x2,c1,c2,w,0.0,(-1.0))->slipstream(afterwards1(x1,y1,w),afterwards2(x2,y2,w)+T()*r(),c1,c2,w,0.0,(-1.0))");
            MR("w>0&c1>0&c2>0&onSide1(x1,x2,c1,c2,w,0.0,(-1.0))", 'R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&(slipstream(x1,x2,c1,c2,w,0.0,(-1.0))|farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))))") ; <(
        "Use Q->P": cut("!!-(p()*y1+r()*z1)-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0") ; <(
            "Use": dIRule('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&onSide1(x1,x2,c1,c2,w,0.0,(-1.0)))") ; <(
                "dI Init": auto,
                "dI Step": auto
              ),
            "Show": notR('R=="!!-(p()*y1+r()*z1)-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0") ; notGreaterEqual('L=="!-(p()*y1+r()*z1)-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0") ; solve('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&onSide1(x1,x2,c1,c2,w,0.0,(-1.0)))") ; unfold ; expand "onSide1" ; expand "onSideGeneric" ; expand "afterwards1" ; expand "afterwards2" ; expand "sp" ; fullSimplify ; cut("t_<=T()") ; <(
                "Use": cut("-((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; <(
                    "Use": allL2R('L=="-((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; hideL('L=="-((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; cut("-(x1+T()*p()*y1+T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; <(
                        "Use": allL2R('L=="-(x1+T()*p()*y1+T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; hideL('L=="-(x1+T()*p()*y1+T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; hideL('L=="\forall s_ (0<=s_&s_<=t_->s_+t<=T())") ; cut("(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1>=(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; <(
                            "Use": abbrv("(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1", "g") ; abbrv("(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1", "h") ; hideL('L=="h=(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; hideL('L=="g=(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1") ; QE using "h>=0 :: g>=h :: g>=0 :: nil",
                            "Show": hideR('R=="(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1>=0") ; cut("-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2)>=-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r())") ; <(
                                "Use": abbrv("-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2)", "g") ; edit("g < 0", 'L=="-(p()*y1+r()*z1)-(p()-r())/w*(-(-w+p()*y2+r()*z2)) < 0") ; hideL('L=="g=-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2)") ; abbrv("-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r())", "g") ; hideL('L=="g=-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r())") ; QE,
                                "Show": QE using "p()>r() :: r()>0 :: z1^2+z2^2<=1 :: w>0 :: y1^2+y2^2<=1 :: -(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2)>=-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()) :: nil"
                              )
                          ),
                        "Show": QE using "-(x1+T()*p()*y1+T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(-(p()*y1+r())+(p()-r())/w*(-w+p()*y2-r()))*T()-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1"
                      ),
                    "Show": QE using "-((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(-(p()*y1+r()*z1)+(p()-r())/w*(-w+p()*y2+r()*z2))*t_-x1-(p()-r())/w*c2+(p()-r())/w*x2-c1"
                  ),
                "Show": QE using "T()>0 :: t=0 :: t_>=0 :: \forall s_ (0<=s_&s_<=t_->s_+t<=T()) :: t_<=T() :: nil"
              )
          ),
        "Show [a]Q": auto
      ),
          "onSide2(x1,x2,c1,c2,w,0.0,(-1.0))":
            MR("w>0&c1>0&c2>0&onSide2(x1,x2,c1,c2,w,0.0,(-1.0))", 'R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&(slipstream(x1,x2,c1,c2,w,0.0,(-1.0))|farAway(x1,x2,c1,c2,w,0.0,(-1.0))|onSide1(x1,x2,c1,c2,w,0.0,(-1.0))|onSide2(x1,x2,c1,c2,w,0.0,(-1.0))))"); <(
              "Use Q->P":
                cut("p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0"); <(
                  "Use":
                    dIRule('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&onSide2(x1,x2,c1,c2,w,0.0,(-1.0)))") ; <(
            "dI Init": auto,
            "dI Step": auto
          ),
                  "Show":
                    edit("!!p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0", 'R=="p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0") ; notR('R=="!!p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0") ; notGreaterEqual('L=="!p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2))>=0") ; solve('R=="[{x1'=p()*y1+r()*z1,x2'=-w+p()*y2+r()*z2,t'=1&t<=T()}](w>0&c1>0&c2>0&onSide2(x1,x2,c1,c2,w,0.0,(-1.0)))") ; unfold ; expand "controllerCondition" ; unfold;
                    hideL('L=="slipstream(x1,x2,c1,c2,w,0.0,(-1.0))->slipstream(afterwards1(x1,y1,w),afterwards2(x2,y2,w)+T()*r(),c1,c2,w,0.0,(-1.0))");
                    hideL('L=="onSide1(x1,x2,c1,c2,w,0.0,(-1.0))->onSide1(afterwards1(x1,y1,w)+T()*r(),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
                    hideL('L=="farAway(x1,x2,c1,c2,w,0.0,(-1.0))->farAway(afterwards1(x1,y1,w),afterwards2(x2,y2,w)-T()*r(),c1,c2,w,0.0,(-1.0))");
                    expand "onSide2" ; expand "onSideGeneric" ; expand "sp" ; expand "afterwards1" ; expand "afterwards2" ; fullSimplify ; cut("--((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; <(
            "Use": allL2R('L=="--((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; hideL('L=="--((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; cut("--(x1+T()*p()*y1-T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; <(
                "Use": allL2R('L=="--(x1+T()*p()*y1-T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; hideL('L=="--(x1+T()*p()*y1-T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; cut("t_<=T()") ; <(
                    "Use": cut("(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2>=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; <(
                        "Use": abbrv("(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2", "g") ; hideL('L=="g=(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; abbrv("(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2", "h") ; hideL('L=="h=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; QE using "h>=0 :: g>=h :: g>=0 :: nil",
                        "Show": hideL('L=="(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2>=0") ; hideL('L=="\forall s_ (0<=s_&s_<=t_->s_+t<=T())") ; hideR('R=="(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2>=0") ; hideL('L=="--x1-((p()-r())/w*(c2-x2)+c1)>=0") ; cut("p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2)>=p()*y1-r()+(p()-r())/w*(-w+p()*y2-r())") ; <(
                            "Use": abbrv("p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2)", "g") ; abbrv("p()*y1-r()+(p()-r())/w*(-w+p()*y2-r())", "h") ; edit("g < 0", 'L=="p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2)) < 0") ; hideL('L=="h=p()*y1-r()+(p()-r())/w*(-w+p()*y2-r())") ; hideL('L=="g=p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2)") ; QE,
                            "Show": hideR('R=="(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2>=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2") ; hideL('L=="p()*y1+r()*z1-(p()-r())/w*(-(-w+p()*y2+r()*z2)) < 0") ; QE
                          )
                      ),
                    "Show": QE using "T()>0 :: t=0 :: t_>=0 :: \forall s_ (0<=s_&s_<=t_->s_+t<=T()) :: t_<=T() :: nil"
                  ),
                "Show": QE using "--(x1+T()*p()*y1-T()*r())-((p()-r())/w*(c2-(x2+T()*p()*y2-T()*w-T()*r()))+c1)=(p()*y1-r()+(p()-r())/w*(-w+p()*y2-r()))*T()+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2"
              ),
            "Show": QE using "--((p()*y1+r()*z1)*t_+x1)-((p()-r())/w*(c2-((-w+p()*y2+r()*z2)*t_+x2))+c1)=(p()*y1+r()*z1+(p()-r())/w*(-w+p()*y2+r()*z2))*t_+x1-c1-(p()-r())/w*c2+(p()-r())/w*x2"
          )
                ),
              "Show [a]Q":
                auto
            )
        )
    )
)
End.
End.